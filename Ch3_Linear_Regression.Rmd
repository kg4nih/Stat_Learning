---
title: "Ch3_Linear_Regression"
author: "G Smith"
date: "September 25, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Chapter 3 Linear Regression

My notes and worked examples for linear regression.

```{r}
# Loading my standard work environment libraries and the ISLR library
library(tidyverse)
library(broom)
library(gridExtra)
library(GGally)
library(knitr)
library(ISLR)
```
## 3.6 Lab: Linear Regression

3.6.1 Libraries

```{r}
# ISLR is already laoded
# Loading MASS library
# Note that the MASS library may mess-up the dplry select() function
# I'm also practicing using tibbies, ggplot and the broom packages
library(MASS)
library(dplyr)
# this was a recommended solution; define select to be the dplyr select() function
select <- dplyr::select
rename <- dplyr::rename
```

```{r}
# loading Boston data set
data(Boston)
head(Boston)
attach(Boston)
```
## 3.6.2 Simple Linear Regression

```{r}
# creating first LM and playing w/ making it tidy
lm.fit <- Boston %>% 
  lm(medv~lstat, data = .)
# looking at the broom functions
lm.fit.tidy <- tidy(lm.fit, conf.int = TRUE, conf.level = .95)
lm.fit.tidy
```

```{r}
names(lm.fit.tidy)
```

```{r}
lm.fit.aug <- augment(lm.fit)
lm.fit.aug
```

```{r}
lm.fit.gla <- glance(lm.fit)
lm.fit.gla
```
```{r}
# using the predict() function
# first build a vector of predictor values
lstat.p <- c(1:30)
# run predict() for p_hat and confidence intervals
# the data.frame() is importatant
lm.fit.p_hat <- predict(lm.fit, data.frame(lstat = lstat.p), interval = "confidence")
lm.fit.p_hat
# tidy p_hat and lstat.p by making them into tibbles
lstat.p <- as.tibble(lstat.p)
lm.fit.p_hat <- as.tibble(lm.fit.p_hat)
# place the predictor values in the p_hat tibble and rename value as lstat
lm.fit.p_hat <- bind_cols(lstat.p,lm.fit.p_hat)
lm.fit.p_hat <- lm.fit.p_hat %>% 
  rename(lstat = value, medv = fit)
lm.fit.p_hat
```
```{r}
# plotting the fitted value for medv vs lstat with lower and upper conf intervals
lm.fit.p_hat %>% 
  ggplot(aes(lstat, medv, ymin = lwr, ymax = upr)) +
  geom_errorbar()
```
```{r}
# and now plotting with geom_smooth
lm.fit.p_hat %>% 
  ggplot(aes(lstat, medv, ymin = lwr, ymax = upr)) +
  geom_smooth(method = lm) + 
  geom_errorbar()
```
```{r}
# using ggplot isn't as easy as using the basic abline(lm.fit) call
# some more plottiong using ggplot
# need to get the intercept and slope from lm.fit.tidy
intercept = pull(lm.fit.tidy[1,2])
slope = pull(lm.fit.tidy[2,2])
# plot lstat vs medv and add abline
Boston %>% 
  ggplot(aes(lstat,medv)) +
  geom_point(alpha = 0.5, color = "red") +
  geom_abline(aes(intercept = intercept, slope = slope))
```
```{r}
# plot(predict(lm.fit), residuals(lm.fit)) is more direct
# than using ggplot
pred <- as.tibble(predict(lm.fit))
pred <- pred %>% 
  rename(pred = value)
resid <- as.tibble(residuals(lm.fit))
resid <-  resid %>%
  rename(resid = value)
tab <- bind_cols(pred,resid)
tab %>% 
ggplot(aes(pred, resid)) + 
  geom_point(alpha = 0.5)
```
```{r}
# using the broom augmented results lm.fit.aug
# this is a lot easier taht the above!
lm.fit.aug %>% 
  ggplot(aes(.fitted, .resid)) +
  geom_point(alpha = 0.5)
```
```{r}
# plotting .hat (leverage) values and determining the observation w/ the largest leverage
# the challege is defining an index value. My solution is 1:nrow()
max_leverage <- tibble(c(which.max(lm.fit.aug$.hat),max(lm.fit.aug$.hat)))
max_leverage
lm.fit.aug %>% 
  ggplot(aes(1:nrow(lm.fit.aug),.hat)) +
  geom_point(alpha = 0.5)
```